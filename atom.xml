<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永远站在鸡蛋一边</title>
  <subtitle>--Zfan的记事簿--</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zvan.xyz/"/>
  <updated>2016-07-25T07:55:50.000Z</updated>
  <id>http://zvan.xyz/</id>
  
  <author>
    <name>Zfan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCD 学习笔记</title>
    <link href="http://zvan.xyz/2016/07/24/GCD%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zvan.xyz/2016/07/24/GCD 学习笔记/</id>
    <published>2016-07-24T08:51:00.000Z</published>
    <updated>2016-07-25T07:55:50.000Z</updated>
    
    <content type="html">&lt;p&gt;开发者所要做的是将想要执行的任务添加到适当的 Dispatch Queue 当中;  &lt;/p&gt;
&lt;h4 id=&quot;Dispatch_Queue_的种类&quot;&gt;Dispatch Queue 的种类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Serial Dispatch Queue&lt;/li&gt;
&lt;li&gt;Concurrent Dispatch Queue&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Serial_Dispatch_Queue&quot;&gt;Serial Dispatch Queue&lt;/h4&gt;&lt;p&gt;Serial Dispatch Queue 中的任务顺序执行, 同时执行的任务数只能为1;  &lt;/p&gt;
&lt;h4 id=&quot;Concurrent_Dispatch_Queue&quot;&gt;Concurrent Dispatch Queue&lt;/h4&gt;&lt;p&gt;Concurrent Dispatch Queue 中的任务可并行处理, 但是并行处理的数量(线程数)取决于当前系统的状态(XNU内核决定了应当使用的线程数);  &lt;/p&gt;
&lt;h4 id=&quot;dispatch_queue_create&quot;&gt;dispatch_queue_create&lt;/h4&gt;&lt;p&gt;通过该函数可以生成 Dispatch Queue:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;生成 Serial Dispatch Queue&lt;span class=&quot;value&quot;&gt;:  
&lt;span class=&quot;function&quot;&gt;dispatch_queue_create&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;com.example.queue&quot;&lt;/span&gt;, NULL);&lt;/span&gt;  

生成 Concurrent Dispatch Queue&lt;span class=&quot;value&quot;&gt;: 
&lt;span class=&quot;function&quot;&gt;dispatch_queue_create&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;com.example.queue&quot;&lt;/span&gt;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦生成一个 Serial Dispatch Queue, 系统就为该 Queue 生成一个线程供其使用; 如果生成过多 Serial Dispatch Queue, 则会产生大量线程, 大幅降低系统的响应性能;  &lt;/p&gt;
&lt;p&gt;对于 Concurrent Dispatch Queue, XNU内核会自动管理所需要的线程数量, 因此不会发生线程生成过多的问题;  &lt;/p&gt;
&lt;p&gt;Queue 的命名推荐使用逆序全程域名;  &lt;/p&gt;
&lt;p&gt;生成的 Queue 类型可以用 &lt;code&gt;dispatch_queue_t&lt;/code&gt; 类型来表示;  &lt;/p&gt;
&lt;p&gt;Dispatch Queue 的内存管理不能使用 ARC, 需要程序员手动管理, 相关函数:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dispatch_release()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;
dispatch_retain()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dispatch Queue 与其中的 Block 相互持有;  &lt;/p&gt;
&lt;h4 id=&quot;Main_Dispatch_Queue_/_Globle_Dispatch_Queue&quot;&gt;Main Dispatch Queue / Globle Dispatch Queue&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Main Dispatch Queue&lt;/code&gt;: 在主线程中执行的 Dispatch_Queue, 属 Serial Dispatch Queue;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Globle Dispatch Queue&lt;/code&gt;: 所有应用程序都能使用的 Concurrent Dispatch Queue;  &lt;/p&gt;
&lt;p&gt;Globle Dispatch Queue 共有四种优先级: High Priority, Default Priority, Low Priority, Background Priority; 执行优先级只是大致的判断;  &lt;/p&gt;
&lt;h4 id=&quot;dispatch_set_target_queue&quot;&gt;dispatch_set_target_queue&lt;/h4&gt;&lt;p&gt;改变生成的 Dispatch Queue 的执行优先级的函数是 dispatch_set_target_queue;  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发者所要做的是将想要执行的任务添加到适当的 Dispatch Queue 当中;  &lt;/p&gt;
&lt;h4 id=&quot;Dispatch_Queue_的种类&quot;&gt;Dispatch Queue 的种类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Serial Dispatch Queue&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="iOS" scheme="http://zvan.xyz/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="GCD" scheme="http://zvan.xyz/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>ARC 学习笔记</title>
    <link href="http://zvan.xyz/2016/07/03/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%20(Auto%20Reference%20Counting)/"/>
    <id>http://zvan.xyz/2016/07/03/自动引用计数 (Auto Reference Counting)/</id>
    <published>2016-07-03T04:18:00.000Z</published>
    <updated>2016-07-25T08:59:58.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;自动引用计数_(Auto_Reference_Counting)&quot;&gt;自动引用计数 (Auto Reference Counting)&lt;/h4&gt;&lt;p&gt;在LLVM编译器中设置ARC为有效状态, 就无需再次输入retain或者release代码.&lt;/p&gt;
&lt;h4 id=&quot;引用计数的思考方式:_&quot;&gt;引用计数的思考方式: &lt;/h4&gt;&lt;p&gt;自己生成的对象, 自己持有;&lt;br&gt;非自己生成的对象, 自己也能持有;&lt;br&gt;不再需要自己持有的对象, 可以释放;&lt;br&gt;非自己持有的对象, 自己不能释放.&lt;/p&gt;
&lt;h4 id=&quot;对象操作与_OC_方法对应&quot;&gt;对象操作与 OC 方法对应&lt;/h4&gt;&lt;p&gt;生成并持有对象    &lt;code&gt;alloc&lt;/code&gt; &lt;code&gt;new&lt;/code&gt; &lt;code&gt;copy&lt;/code&gt; &lt;code&gt;mutableCopy&lt;/code&gt; (自己生成的对象, 自己持有)&lt;br&gt;持有对象    &lt;code&gt;retain&lt;/code&gt; (非自己生成的对象, 自己也能持有)&lt;br&gt;释放对象    &lt;code&gt;release&lt;/code&gt;  (不需要自己持有的对象, 可以释放)&lt;br&gt;废弃对象    &lt;code&gt;dealloc&lt;/code&gt;   ()&lt;/p&gt;
&lt;h4 id=&quot;alloc方法的内部实现&quot;&gt;alloc方法的内部实现&lt;/h4&gt;&lt;p&gt;通过 allocWithZone: 类方法调用 NSAllocateObject 函数分配对象; NSAllocateObject函数通过调用NSZoneMalloc函数来分配存放对象所需的内存空间, 之后将此内存空间置为0, 最后返回对象的指针;&lt;/p&gt;
&lt;p&gt;引用计数的保存: 苹果的实现是通过散列表来保存引用计数;&lt;/p&gt;
&lt;h4 id=&quot;AutoRelease的内部实现&quot;&gt;AutoRelease的内部实现&lt;/h4&gt;&lt;p&gt;通过将 autoRelease 的对象加入内部数组, 在 AutoReleasePool 生命周期结束的时候统一调用内部数组中对象的 release 方法实现的;&lt;/p&gt;
&lt;h4 id=&quot;ARC_规则&quot;&gt;ARC 规则&lt;/h4&gt;&lt;p&gt;一个应用程序中可以混合 ARC 和 MRC;&lt;/p&gt;
&lt;p&gt;对象类型必须附加所有权修饰符 (没有明确指定所有权修饰符时, 默认为__strong);  &lt;/p&gt;
&lt;p&gt;四种所有权修饰符:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__strong&lt;/code&gt;, &lt;code&gt;__weak&lt;/code&gt;, &lt;code&gt;__unsafe__unretained&lt;/code&gt;, &lt;code&gt;__autoreleasing&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;__strong&lt;/code&gt;, &lt;code&gt;__weak&lt;/code&gt;, &lt;code&gt;__autoreleasing&lt;/code&gt; 可以保证将有这些修饰符的自动变量初始化为nil;&lt;/p&gt;
&lt;p&gt;循环引用既可以是交叉引用, 也可能是对自身的强引用; 使用__weak修饰符可以避免循环引用;&lt;/p&gt;
&lt;p&gt;__weak修饰符修饰的对象若被废弃, 则该弱引用将被自动置为nil; 而&lt;code&gt;__unsafe__unretained&lt;/code&gt;修饰符则无此特性;&lt;/p&gt;
&lt;p&gt;__weak修饰符只能应用于 iOS5 以上版本;&lt;/p&gt;
&lt;p&gt;ARC 环境下通过 __autoreleasing 修饰符来代替 autorelease 方法; 通过 &lt;code&gt;@autorelease {}&lt;/code&gt; 来代替 NSAutoReleasePool 类;&lt;/p&gt;
&lt;p&gt;在 AutoReleasePool 中生成的对象, 编译器会自动检查方法名是否以 alloc/new/copy/mutableCopy 开始, 如果不是则自动将返回的对象注册到 autoreleasepool;  &lt;/p&gt;
&lt;p&gt;对象的指针在没有显式指定时会被附上 __autoreleasing 修饰符;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自动引用计数_(Auto_Reference_Counting)&quot;&gt;自动引用计数 (Auto Reference Counting)&lt;/h4&gt;&lt;p&gt;在LLVM编译器中设置ARC为有效状态, 就无需再次输入retain或者release代码.&lt;/p&gt;
&lt;h4 id
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="ARC" scheme="http://zvan.xyz/tags/ARC/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习笔记(二)--链式编程</title>
    <link href="http://zvan.xyz/2016/01/29/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)--%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://zvan.xyz/2016/01/29/ReactiveCocoa学习笔记(二)--链式编程/</id>
    <published>2016-01-29T04:43:23.000Z</published>
    <updated>2016-01-29T08:04:14.000Z</updated>
    
    <content type="html">&lt;p&gt;首先观察使用Masonry框架的这段代码:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;View&lt;/span&gt; mas_makeConstraints:^&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;MASConstrainMaker&lt;/span&gt; *make)&lt;/span&gt; {
    make.left.top.equalTo&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@10&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;
    make.right.bottom.equalTo&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@-10&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;
}]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它的的作用是为View的上下左右各添加10像素间隔的约束;&lt;/p&gt;
&lt;p&gt;这段代码的内部实现运用了链式编程思想, 其有两个特点:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 链式调用: 通过一长串点语法链接的形式简单明确地实现相应功能;  
&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 高聚合度: 将对约束的处理统一放在一个block块中, 使同类代码聚合在一起;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先分析链式调用是怎么实现的:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (&lt;span class=&quot;constant&quot;&gt;MASConstraint&lt;/span&gt; *)&lt;span class=&quot;symbol&quot;&gt;constraint:&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;MASConstraint&lt;/span&gt; *)constraint &lt;span class=&quot;symbol&quot;&gt;addConstraintWithLayoutAttribute:&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;NSLayoutAttribute&lt;/span&gt;)layoutAttribute {
&lt;span class=&quot;constant&quot;&gt;MASViewAttribute&lt;/span&gt; *viewAttribute = [[&lt;span class=&quot;constant&quot;&gt;MASViewAttribute&lt;/span&gt; alloc] &lt;span class=&quot;symbol&quot;&gt;initWithView:&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view &lt;span class=&quot;symbol&quot;&gt;layoutAttribute:&lt;/span&gt;layoutAttribute];
&lt;span class=&quot;constant&quot;&gt;MASViewConstraint&lt;/span&gt; *newConstraint = [[&lt;span class=&quot;constant&quot;&gt;MASViewConstraint&lt;/span&gt; alloc] &lt;span class=&quot;symbol&quot;&gt;initWithFirstViewAttribute:&lt;/span&gt;viewAttribute];
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([constraint &lt;span class=&quot;symbol&quot;&gt;isKindOfClass:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;MASViewConstraint&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]) {
    &lt;span class=&quot;regexp&quot;&gt;//replace&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; composite constraint
    &lt;span class=&quot;constant&quot;&gt;NSArray&lt;/span&gt; *children = &lt;span class=&quot;annotation&quot;&gt;@[constraint, newConstraint]&lt;/span&gt;;
    &lt;span class=&quot;constant&quot;&gt;MASCompositeConstraint&lt;/span&gt; *compositeConstraint = [[&lt;span class=&quot;constant&quot;&gt;MASCompositeConstraint&lt;/span&gt; alloc] &lt;span class=&quot;symbol&quot;&gt;initWithChildren:&lt;/span&gt;children];
    compositeConstraint.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;
    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;constraint:&lt;/span&gt;constraint &lt;span class=&quot;symbol&quot;&gt;shouldBeReplacedWithConstraint:&lt;/span&gt;compositeConstraint];
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; compositeConstraint;
}
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!constraint) {
    newConstraint.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;
    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.constraints &lt;span class=&quot;symbol&quot;&gt;addObject:&lt;/span&gt;newConstraint];
}
&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; newConstraint;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在该方法中, make.left 会新建一个 constraint 元素, 并添加到 make 的 constraints 数组中, 接着将该元素的代理设置为 make 本身, 最后返回该 constraint 元素;&lt;/p&gt;
&lt;p&gt;类似地, make.left.top 也会控制其代理(即上一步中的make本身)新建一个 constraint 元素, 并添加到 make 的 constraints 数组中, 接着将其将该元素的代理设置为 make 本身, 最后返回该 constraint 元素, 通过这样的调用循环往复, 实现链式调用的效果;  &lt;/p&gt;
&lt;p&gt;最终 make.left.top.equal(@10) 中的 .equal 方法会返回一个 block , 我们只需要像调用一个普通 block 一样将参数填在其后的括号里就完成了整个方法的调用;  &lt;/p&gt;
&lt;p&gt;这种编程方式的另外一个特点就是代码的高聚合度, 将我们需要做的操作统一塞在block块里, 方便查看和管理;  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先观察使用Masonry框架的这段代码:  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;View&lt;/span&gt; mas_makeConstraints:^&lt;span class=&quot;list&quot;&gt;(&lt;sp
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://zvan.xyz/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa框架学习笔记(一)--ReactiveCocoa简介</title>
    <link href="http://zvan.xyz/2016/01/26/ReactiveCocoa%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)--ReactiveCocoa%E7%AE%80%E4%BB%8B/"/>
    <id>http://zvan.xyz/2016/01/26/ReactiveCocoa框架学习笔记(一)--ReactiveCocoa简介/</id>
    <published>2016-01-26T07:41:54.000Z</published>
    <updated>2016-01-29T03:53:39.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-_编程思想&quot;&gt;1. 编程思想&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 面向过程: 处理事件以过程为核心, 一步一步实现;  
&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 面向对象;  
&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt; 链式编程思想: 将多个操作通过.符号链接在一起成为一句代码, 使代码可读性好;  
&lt;span class=&quot;number&quot;&gt;4.&lt;/span&gt; 响应式编程: 不需要考虑调用程序, 只需要考虑结果, 事件像流一样传播出去, 然后影响结果;  
&lt;span class=&quot;number&quot;&gt;5.&lt;/span&gt; 函数式编程: 把操作携程一系列嵌套的函数或者方法调用;  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-_ReactiveCocoa的作用&quot;&gt;2.  ReactiveCocoa的作用&lt;/h3&gt;&lt;p&gt;将action, delegate, KVO, callback等等事件处理方式统一通过RAC来处理, 这样可以&lt;code&gt;将处理事件的代码和监听事件的代码放在一起&lt;/code&gt;, 方便程序员来管理, 符合开发中&lt;code&gt;高聚合, 低耦合&lt;/code&gt;的思想;  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-_编程思想&quot;&gt;1. 编程思想&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 面向过程: 处理事件以过程为核心, 一步一步实现;  
&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt; 面向对象;  
&lt;s
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://zvan.xyz/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记(五)--栈与队列</title>
    <link href="http://zvan.xyz/2016/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)--%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://zvan.xyz/2016/01/26/数据结构学习笔记(五)--栈与队列/</id>
    <published>2016-01-26T07:38:05.000Z</published>
    <updated>2016-01-26T07:38:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;栈与队列&quot;&gt;栈与队列&lt;/h3&gt;&lt;p&gt;它们都是一种受限制的数据结构;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈(stack) &lt;ul&gt;
&lt;li&gt;运算只在表的一端进行;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列(Queue) &lt;ul&gt;
&lt;li&gt;运算只在表的两端进行;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;栈定义&quot;&gt;栈定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;后进先出 (Last In First Out)&lt;ul&gt;
&lt;li&gt;一种限制访问端口的线性表;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要操作&lt;ul&gt;
&lt;li&gt;进栈(Push); 出栈(Pop);  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用&lt;ul&gt;
&lt;li&gt;表达式求值;  &lt;/li&gt;
&lt;li&gt;消除递归;&lt;/li&gt;
&lt;li&gt;深度优化搜索;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;栈的实现方式&quot;&gt;栈的实现方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序栈(Array-Based Stack)  &lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;栈与队列&quot;&gt;栈与队列&lt;/h3&gt;&lt;p&gt;它们都是一种受限制的数据结构;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈(stack) &lt;ul&gt;
&lt;li&gt;运算只在表的一端进行;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列(Queue) &lt;ul&gt;
&lt;li&gt;运算只在表的两端进行;
    
    </summary>
    
      <category term="数据结构" scheme="http://zvan.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zvan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈" scheme="http://zvan.xyz/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://zvan.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记(四)--顺序表和链表的比较</title>
    <link href="http://zvan.xyz/2016/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)--%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://zvan.xyz/2016/01/09/数据结构学习笔记(四)--顺序表和链表的比较/</id>
    <published>2016-01-09T07:40:40.000Z</published>
    <updated>2016-01-09T08:13:41.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;线性表实现方式的比较&quot;&gt;线性表实现方式的比较&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序表的主要优点&lt;ul&gt;
&lt;li&gt;没有使用指针, 不用花费额外开销;  &lt;/li&gt;
&lt;li&gt;线性表元素的读访问非常简洁便利;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链表的主要优点&lt;ul&gt;
&lt;li&gt;无需事先知道线性表的长度;  &lt;/li&gt;
&lt;li&gt;允许线性表的长度动态变化;  &lt;/li&gt;
&lt;li&gt;能够使用经常插入删除内部元素的情况;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结&lt;ul&gt;
&lt;li&gt;顺序表是存储静态数据的不二选择;  &lt;/li&gt;
&lt;li&gt;链表式存储动态变化数据的良方;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;顺序表和链表的比较&quot;&gt;顺序表和链表的比较&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序表&lt;ul&gt;
&lt;li&gt;插入/删除运算时间代价O(n), 查找则可常数时间完成;  &lt;/li&gt;
&lt;li&gt;预先申请固定长度的连续空间;  &lt;/li&gt;
&lt;li&gt;如果整个数组元素很满, 则没有结构性存储开销;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链表&lt;ul&gt;
&lt;li&gt;插入/删除运算时间代价O(1), 但找到第i个元素运算时间代价为O(n);  &lt;/li&gt;
&lt;li&gt;存储利用指针, 动态地按照需要为表中新的元素分配存储空间;  &lt;/li&gt;
&lt;li&gt;每个元素都有结构性存储开销;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;存储密度对比&quot;&gt;存储密度对比&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;已知空间需求:&lt;ul&gt;
&lt;li&gt;顺序表的空间需求为DE;  &lt;/li&gt;
&lt;li&gt;链表的空间需求为n(P + E);  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;n越大, 顺序表的空间效率就更高;  &lt;/li&gt;
&lt;li&gt;如果P = E, 则临界值为n = D / 2; 即当顺序表的存储元素超过长度的一半时, 顺序表的存储效率便超过链表;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;应用场合的选择&quot;&gt;应用场合的选择&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序表不适用的场合&lt;ul&gt;
&lt;li&gt;经常插入删除时, 不宜使用顺序表;  &lt;/li&gt;
&lt;li&gt;线性表的最大长度也是一个重要因素;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链表不适合的场合&lt;ul&gt;
&lt;li&gt;当读取操作比插入删除操作频率大时, 不应选择链表;  &lt;/li&gt;
&lt;li&gt;当指针的存储开销, 和整个节点内容所占空间相比例较大时, 应该慎重选择;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线性表实现方式的比较&quot;&gt;线性表实现方式的比较&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;顺序表的主要优点&lt;ul&gt;
&lt;li&gt;没有使用指针, 不用花费额外开销;  &lt;/li&gt;
&lt;li&gt;线性表元素的读访问非常简洁便利;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链表的主要优点&lt;ul
    
    </summary>
    
      <category term="数据结构" scheme="http://zvan.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zvan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="顺序表" scheme="http://zvan.xyz/tags/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
      <category term="链表" scheme="http://zvan.xyz/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>摇滚音乐史学习笔记(一)--摇滚乐诞生之前</title>
    <link href="http://zvan.xyz/2016/01/07/%E6%91%87%E6%BB%9A%E9%9F%B3%E4%B9%90%E5%8F%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)--%E6%91%87%E6%BB%9A%E4%B9%90%E8%AF%9E%E7%94%9F%E4%B9%8B%E5%89%8D/"/>
    <id>http://zvan.xyz/2016/01/07/摇滚音乐史学习笔记(一)--摇滚乐诞生之前/</id>
    <published>2016-01-07T07:29:07.000Z</published>
    <updated>2016-01-07T13:13:25.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;摇滚乐诞生的时间&quot;&gt;摇滚乐诞生的时间&lt;/h3&gt;&lt;p&gt;大多数学者认为，摇滚乐诞生于1955年前后；&lt;/p&gt;
&lt;h3 id=&quot;摇滚乐的起源&quot;&gt;摇滚乐的起源&lt;/h3&gt;&lt;p&gt;摇滚乐是1955年之前流行乐坛中三种主要音乐风格混合后的产物：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主流流行乐 (Mainstream Pop)&lt;br&gt;西部乡村音乐 (Country and Western Music)&lt;br&gt;R&amp;amp;B  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1955年前的主流流行音乐&quot;&gt;1955年前的主流流行音乐&lt;/h3&gt;&lt;p&gt;在摇滚乐诞生之前,主流流行乐最重要的部分是&lt;code&gt;歌曲本身&lt;/code&gt;，而不是特定的表演版本；&lt;/p&gt;
&lt;p&gt;当时的主流流行音乐产业是由音乐发行商驱动的，他们的主要工作是替写歌的人发行他们的作品,他们出售这些歌曲的主要方式还是&lt;code&gt;卖曲谱&lt;/code&gt;，人们会把曲谱买回家并且演奏它们；而摇滚乐并不十分依赖曲谱，这成为其后来能打破流行音乐市场的原因之一；&lt;/p&gt;
&lt;p&gt;在那时，歌曲创作者和表演者被看作两种不同的职业；而从六十年代中期开始情况发生了改变,许多歌手都演唱自己写的歌;&lt;/p&gt;
&lt;h3 id=&quot;1955年之前主流流行音乐歌手及作品&quot;&gt;1955年之前主流流行音乐歌手及作品&lt;/h3&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;Bing_Crospy&quot;&gt;Bing Crospy&lt;/h4&gt;&lt;p&gt;“I’ve Got a Pocketful of Dreams” (1938)&lt;br&gt;“Only Forever” (1940)&lt;br&gt;“Swinging On a Star” (1944)&lt;br&gt;“White Christmas” (1942,1945)  &lt;/p&gt;
&lt;h4 id=&quot;Glenn_Miller_Orchestra&quot;&gt;Glenn Miller Orchestra&lt;/h4&gt;&lt;p&gt;“String of Pearls” (1942)  &lt;/p&gt;
&lt;h4 id=&quot;The_Andrews_Sisters&quot;&gt;The Andrews Sisters&lt;/h4&gt;&lt;p&gt;“In the Mood”&lt;br&gt;“Bei Mir bist du Schoen” (1938)&lt;br&gt;“Shoo Shoo Baby” (1943)&lt;br&gt;“Rum and Coca Cola” (1945)  &lt;/p&gt;
&lt;h4 id=&quot;The_Mills_Brothers&quot;&gt;The Mills Brothers&lt;/h4&gt;&lt;p&gt;“Paper Doll” (1943)&lt;br&gt;“You Always hurt The One You Love” (1944)&lt;/p&gt;
&lt;h4 id=&quot;Frank_Sinatra&quot;&gt;Frank Sinatra&lt;/h4&gt;&lt;p&gt;“Nancy(with the Laughing Face)” (1945)&lt;br&gt;“All of Me” (1948)&lt;br&gt;“I’ve Got a Crush On You” (1948)  &lt;/p&gt;
&lt;h4 id=&quot;Johnnie_Ray&quot;&gt;Johnnie Ray&lt;/h4&gt;&lt;p&gt;“Cry” (1951)  &lt;/p&gt;
&lt;h4 id=&quot;Tony_Bennett&quot;&gt;Tony Bennett&lt;/h4&gt;&lt;p&gt;“Rags to Riches” (1953)&lt;/p&gt;
&lt;h4 id=&quot;Eddie_Fisher&quot;&gt;Eddie Fisher&lt;/h4&gt;&lt;p&gt;“Oh!My Papa” (1954)&lt;/p&gt;
&lt;h4 id=&quot;Patti_Page&quot;&gt;Patti Page&lt;/h4&gt;&lt;p&gt;“Tennessee Waltz” (1950)&lt;/p&gt;
&lt;h4 id=&quot;Les_Paul_and_Mary_Ford&quot;&gt;Les Paul and Mary Ford&lt;/h4&gt;&lt;p&gt;“How High The Moon” (1951)&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;摇滚乐诞生的时间&quot;&gt;摇滚乐诞生的时间&lt;/h3&gt;&lt;p&gt;大多数学者认为，摇滚乐诞生于1955年前后；&lt;/p&gt;
&lt;h3 id=&quot;摇滚乐的起源&quot;&gt;摇滚乐的起源&lt;/h3&gt;&lt;p&gt;摇滚乐是1955年之前流行乐坛中三种主要音乐风格混合后的产物：&lt;/p&gt;
&lt;blockquote&gt;

    
    </summary>
    
      <category term="音乐" scheme="http://zvan.xyz/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
      <category term="音乐" scheme="http://zvan.xyz/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="摇滚乐" scheme="http://zvan.xyz/tags/%E6%91%87%E6%BB%9A%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记(三)--线性表</title>
    <link href="http://zvan.xyz/2016/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)--%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://zvan.xyz/2016/01/06/数据结构学习笔记(三)--线性表/</id>
    <published>2016-01-06T14:41:36.000Z</published>
    <updated>2016-01-08T07:42:50.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;线性表的概念&quot;&gt;线性表的概念&lt;/h3&gt;&lt;p&gt;线性表简称表, 是零个或多个元素的有穷序列.&lt;/p&gt;
&lt;h3 id=&quot;线性结构&quot;&gt;线性结构&lt;/h3&gt;&lt;p&gt;有一个唯一的开始节点, 其没有前驱, 有一个唯一的直接后继;&lt;br&gt;有一个唯一的终止节点, 其没有后继, 有一个唯一的直接前驱;&lt;br&gt;其他的节点称为内部节点, 每一个内部节点有且仅有一个唯一的直接前驱和一个唯一的直接后继;&lt;br&gt;具有反对称性和传递性;  &lt;/p&gt;
&lt;h3 id=&quot;线性结构的特点&quot;&gt;线性结构的特点&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;均匀性:同一线性表的各数据元素必定具有相同的数据类型和长度;&lt;/li&gt;
&lt;li&gt;有序性:数据元素之间的相对位置是线性的;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线性结构的分类&quot;&gt;线性结构的分类&lt;/h3&gt;&lt;p&gt;按照复杂程度划分:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;简单的:线性表,栈,队列,散列表等等;&lt;/li&gt;
&lt;li&gt;复杂的:广义表,多维数组,文件等等;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照访问方式划分:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;直接访问型&lt;/li&gt;
&lt;li&gt;顺序访问型&lt;/li&gt;
&lt;li&gt;目录索引型&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照操作划分:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;线性表:不限制操作形式,分为顺序表或链表;  &lt;/li&gt;
&lt;li&gt;栈:插入和删除都限制在一端进行;  &lt;/li&gt;
&lt;li&gt;队列:插入操作在表的一端,删除操作在表的另一端;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线性表的存储结构&quot;&gt;线性表的存储结构&lt;/h3&gt;&lt;p&gt;1.顺序表&lt;/p&gt;
&lt;p&gt;按照索引值从小到大存放在一片相邻的区域内;紧凑结构,存储密度为1;&lt;/p&gt;
&lt;p&gt;2.链表&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单链表  &lt;/li&gt;
&lt;li&gt;双链表  &lt;/li&gt;
&lt;li&gt;循环链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;顺序表&quot;&gt;顺序表&lt;/h3&gt;&lt;p&gt;顺序表也称&lt;code&gt;向量&lt;/code&gt;,采用定长的一维数组存储结构;&lt;/p&gt;
&lt;p&gt;顺序表的主要特性:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;元素的类型相同&lt;br&gt;元素&lt;code&gt;顺序&lt;/code&gt;地存储在连续的存储空间中,每一个元素有相同的索引值;&lt;br&gt;使用常数作为向量长度  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顺序表的插入和删除时间代价相同,均为O(n);&lt;/p&gt;
&lt;h3 id=&quot;链表&quot;&gt;链表&lt;/h3&gt;&lt;p&gt;链表通过&lt;code&gt;指针&lt;/code&gt;把它的一串存储节点链接成一个链;&lt;/p&gt;
&lt;p&gt;存储节点由两部分组成:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据域 + 指针域(后继地址)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表的分类:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单链表  &lt;/li&gt;
&lt;li&gt;双链表  &lt;/li&gt;
&lt;li&gt;循环链表  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;单链表&quot;&gt;单链表&lt;/h3&gt;&lt;p&gt;带头结点的单链表: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;整个单链表具有一个头结点: head;&lt;br&gt;第一个结点: head -&amp;gt; next, head != NULL;&lt;br&gt;空表判断: head -&amp;gt; next == NULL;&lt;br&gt;当前结点(一般由其前驱表示): fence -&amp;gt; next;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单链表的运算:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于任何一个结点操作, 必须先找到它;&lt;br&gt;寻找单链表中的任何一个节点, 必须从第一个结点开始;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单链表的时间复杂度: O(n);  &lt;/p&gt;
&lt;h3 id=&quot;双链表&quot;&gt;双链表&lt;/h3&gt;&lt;p&gt;为了弥补单链表的不足, 产生了双链表;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单链表的 next 字段只能仅仅指向后继结点, 不能有效找到前驱;&lt;br&gt;双链表增加了一个指向前驱的指针;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;循环链表&quot;&gt;循环链表&lt;/h3&gt;&lt;p&gt;将单链表或者双链表的头尾结点连接起来, 就是一个循环链表;&lt;br&gt;不增加额外存储花销, 却给不少操作带来了方便; 从循环链表的任何一个结点出发, 都能访问到表中的其他节点;  &lt;/p&gt;
&lt;h3 id=&quot;链表的边界条件&quot;&gt;链表的边界条件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;几个特殊点的处理  &lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;头指针处理  &lt;/li&gt;
&lt;li&gt;非循环链表表尾结点的指针域保持为NULL;  &lt;/li&gt;
&lt;li&gt;循环链表表尾结点的指针指回头结点;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;链表处理  &lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;空链表的特殊处理  &lt;/li&gt;
&lt;li&gt;插入或删除结点时指针勾链的顺序;  &lt;/li&gt;
&lt;li&gt;指针移动的正确性;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;线性表的概念&quot;&gt;线性表的概念&lt;/h3&gt;&lt;p&gt;线性表简称表, 是零个或多个元素的有穷序列.&lt;/p&gt;
&lt;h3 id=&quot;线性结构&quot;&gt;线性结构&lt;/h3&gt;&lt;p&gt;有一个唯一的开始节点, 其没有前驱, 有一个唯一的直接后继;&lt;br&gt;有一个唯一的终止节点, 其没有后继, 有一个唯
    
    </summary>
    
      <category term="数据结构" scheme="http://zvan.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zvan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表" scheme="http://zvan.xyz/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记(二)--算法</title>
    <link href="http://zvan.xyz/2015/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://zvan.xyz/2015/12/24/数据结构学习笔记(二)/</id>
    <published>2015-12-24T10:23:44.000Z</published>
    <updated>2016-01-06T05:20:50.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本算法分类&quot;&gt;基本算法分类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;穷举法
回溯,搜索
递归分治
贪心法
动态规划
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;大O表示法的运算规则&quot;&gt;大O表示法的运算规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;加法规则: f1(n) + f2(n) = O(max(f1(n), f2(n)))
乘法规则: f1(n) * f2(n) = O(f1(n) * f2(n))
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;大Ω表示法&quot;&gt;大Ω表示法&lt;/h3&gt;&lt;p&gt;大O表示法和大Ω表示法唯一区别在于不等式的方向;&lt;/p&gt;
&lt;p&gt;采用大Ω表示法时,最好找出函数增值率所有下限中最大的下限;&lt;/p&gt;
&lt;h3 id=&quot;大Θ表示法&quot;&gt;大Θ表示法&lt;/h3&gt;&lt;p&gt;当上、下限相同时可以用大Θ表示法;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本算法分类&quot;&gt;基本算法分类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;穷举法
回溯,搜索
递归分治
贪心法
动态规划
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;大O表示法的运算规则&quot;&gt;大O表示法的运算规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;加法规则: f1(n) + f2(n)
    
    </summary>
    
      <category term="数据结构" scheme="http://zvan.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zvan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://zvan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构学习笔记(一)</title>
    <link href="http://zvan.xyz/2015/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://zvan.xyz/2015/12/22/数据结构学习笔记(一)/</id>
    <published>2015-12-22T07:23:53.000Z</published>
    <updated>2016-01-06T05:20:42.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;数据的逻辑结构&quot;&gt;数据的逻辑结构&lt;/h3&gt;&lt;p&gt;根据数据元素关系间的基本特性，有四种基本数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;集合（数据元素同属一个集合，但无其他关系）
线性结构（一对一）
树形结构（一对多）
图状结构（多对多）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;数据的物理结构&quot;&gt;数据的物理结构&lt;/h3&gt;&lt;p&gt;亦称存储结构，是数据在计算机存储器内的表示。存储结构可分为4大类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;顺序（借助元素在存储器中的相对位置来表示）
链式（借助指示元素存储地址的指针来表示）
索引
散列
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;数据的运算&quot;&gt;数据的运算&lt;/h3&gt;&lt;p&gt;常用的数据运算方法有5种:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;插入,删除,修改,查找,排序
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;算法特性&quot;&gt;算法特性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;输入,输出,有穷性,确定性,可行性
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;算法效率的度量&quot;&gt;算法效率的度量&lt;/h3&gt;&lt;p&gt;&lt;code&gt;O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O(n²) &amp;lt; O(n³) &amp;lt; O(2的n次方) &amp;lt; O(n!) &amp;lt; O(n的n次方)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间与空间互换&quot;&gt;时间与空间互换&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据的逻辑结构&quot;&gt;数据的逻辑结构&lt;/h3&gt;&lt;p&gt;根据数据元素关系间的基本特性，有四种基本数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;集合（数据元素同属一个集合，但无其他关系）
线性结构（一对一）
树形结构（一对多）
图状结构（多对多）
&lt;/code&gt;&lt;/pre&gt;&lt;h
    
    </summary>
    
      <category term="数据结构" scheme="http://zvan.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zvan.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>为什么Objective-C不能在栈上创建对象</title>
    <link href="http://zvan.xyz/2015/12/16/%E4%B8%BA%E4%BB%80%E4%B9%88Objective-C%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://zvan.xyz/2015/12/16/为什么Objective-C不能在栈上创建对象/</id>
    <published>2015-12-16T05:53:06.000Z</published>
    <updated>2016-01-06T02:29:32.000Z</updated>
    
    <content type="html">&lt;p&gt;本文参考：&lt;a href=&quot;http://blog.csdn.net/cocoarannie/article/details/9956281&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cocoarannie/article/details/9956281&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了搞清楚这个问题，首先需要了解一些预备知识：  &lt;/p&gt;
&lt;p&gt;一个由C/C++编译的程序所占用的内存主要分为以下几个部分：&lt;br&gt;1.栈区(stack)–由编译器自动分配释放，主要存放函数的参数，局部变量的值等；操作方式类似于数据结构的栈；&lt;br&gt;2.堆区(heap)–一般由程序员分配释放，程序结束后会被系统统一回收；需要注意它与数据结构中的堆有区别，分配方式类似于链表；&lt;br&gt;3.全局区(静态区域 static)–全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在另一块区域，程序结束后由系统统一释放；&lt;br&gt;4.文字常量区–常量字符串就存放在这里；程序结束后由系统统一释放；&lt;br&gt;5.程序代码区–存放函数体的二进制代码；&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考：&lt;a href=&quot;http://blog.csdn.net/cocoarannie/article/details/9956281&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/cocoarannie/a
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="栈与堆" scheme="http://zvan.xyz/tags/%E6%A0%88%E4%B8%8E%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>内存管理学习笔记</title>
    <link href="http://zvan.xyz/2015/12/16/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zvan.xyz/2015/12/16/内存管理学习笔记/</id>
    <published>2015-12-16T05:50:53.000Z</published>
    <updated>2016-01-06T05:20:18.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-内存管理的必要性&quot;&gt;1.内存管理的必要性&lt;/h3&gt;&lt;p&gt;C语言中需要通过malloc()和free()函数对内存进行管理；&lt;/p&gt;
&lt;p&gt;如果程序未释放不再使用的内存，则会发生内存泄露；&lt;/p&gt;
&lt;p&gt;指向已经被释放的对象的指针，叫做悬垂指针或野指针；如果访问了已经被释放的内存，则会发生数据错误；&lt;/p&gt;
&lt;p&gt;Objective-C会向类对象发送alloc消息来生成实例对象，alloc的作用就是分配内存；alloc返回的对象是id类型，id实质上就是指针类型，其指向的就是为实例对象分配的内存；&lt;/p&gt;
&lt;h3 id=&quot;2-引用计数&quot;&gt;2.引用计数&lt;/h3&gt;&lt;p&gt;Objective-C使用了一种动态的内存管理方式，称为引用计数；每个对象都有一个与之相关的整数，称作它的引用计数；系统会动态跟踪对象被引用的次数，当该对象被retain时就将其引用计数加1，当该对象被release时其引用计数减1，当对象的引用次数为0时，系统会释放这个对象并回收其占用的内存；&lt;/p&gt;
&lt;p&gt;自动引用计数(ARC)会在程序编译期间自动加入合适的内存管理方法；&lt;/p&gt;
&lt;p&gt;释放内存的方法是dealloc方法，这是一个实例方法，当对象的引用计数为0时，系统会调用该对象的dealloc方法释放其内存，通常不允许在程序中直接调用该方法；&lt;/p&gt;
&lt;p&gt;retain是”保持”的意思，对一个对象发送retain消息，就意味着拥有这个对象的所有权；给对象发送release消息意味放弃该对象的所有权；&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-内存管理的必要性&quot;&gt;1.内存管理的必要性&lt;/h3&gt;&lt;p&gt;C语言中需要通过malloc()和free()函数对内存进行管理；&lt;/p&gt;
&lt;p&gt;如果程序未释放不再使用的内存，则会发生内存泄露；&lt;/p&gt;
&lt;p&gt;指向已经被释放的对象的指针，叫做悬垂指针或野指针；如果访问
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="内存" scheme="http://zvan.xyz/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>解决升级Xcode7.1后，Cordova工程Archive打包找不到头文件的问题</title>
    <link href="http://zvan.xyz/2015/10/31/%E8%A7%A3%E5%86%B3%E5%8D%87%E7%BA%A7Xcode7.1%E5%90%8ECordova%E5%B7%A5%E7%A8%8BArchive%E6%89%93%E5%8C%85%E6%89%BE%E4%B8%8D%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zvan.xyz/2015/10/31/解决升级Xcode7.1后Cordova工程Archive打包找不到头文件的问题/</id>
    <published>2015-10-30T18:28:29.000Z</published>
    <updated>2015-11-20T15:48:43.000Z</updated>
    
    <content type="html">&lt;p&gt;在Build Settings-&amp;gt;Search Paths-&amp;gt;Header Search Paths-&amp;gt;Release下添加如下路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“&lt;span class=&quot;variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;OBJROOT&lt;/span&gt;)/&lt;span class=&quot;constant&quot;&gt;UninstalledProducts&lt;/span&gt;/&lt;span class=&quot;variable&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;PLATFORM_NAME&lt;/span&gt;)/&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;”
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://forum.ionicframework.com/t/cordova-cdvviewcontroller-h-file-not-found-in-xcode-7-1-beta/32232&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://forum.ionicframework.com/t/cordova-cdvviewcontroller-h-file-not-found-in-xcode-7-1-beta/32232&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Build Settings-&amp;gt;Search Paths-&amp;gt;Header Search Paths-&amp;gt;Release下添加如下路径：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“&lt;span class=&quot;variable&quot;&gt;$(&lt;/span&gt;&lt;span class=
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS开发" scheme="http://zvan.xyz/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="Xcode" scheme="http://zvan.xyz/tags/Xcode/"/>
    
      <category term="Cordova" scheme="http://zvan.xyz/tags/Cordova/"/>
    
      <category term="PhoneGap" scheme="http://zvan.xyz/tags/PhoneGap/"/>
    
  </entry>
  
  <entry>
    <title>消息机制</title>
    <link href="http://zvan.xyz/2015/10/28/iOS%E5%BC%80%E5%8F%91--%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>http://zvan.xyz/2015/10/28/iOS开发--消息分发机制/</id>
    <published>2015-10-28T15:24:07.000Z</published>
    <updated>2015-10-29T01:25:21.000Z</updated>
    
    <content type="html">&lt;ol&gt;
&lt;li&gt;objc_msgSend函数&lt;br&gt;在Objective-C语言中，消息直到运行时才会与具体的方法实现进行绑定。OC编译器将此种格式的消息&lt;br&gt; [receiver message]&lt;br&gt;的转换为objc_msgSend的函数调用。这个函数将消息的接受者与该方法的名称，即该方法的selector，作为它的两个重要参数：&lt;br&gt; objc_msgSend(receiver, selector)&lt;br&gt;该消息中的各个参数也通过objc_msgSend函数传递：&lt;br&gt; objc_msgSend(receiver, selector, arg1, arg2, …)&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;objc_msgSend函数&lt;br&gt;在Objective-C语言中，消息直到运行时才会与具体的方法实现进行绑定。OC编译器将此种格式的消息&lt;br&gt; [receiver message]&lt;br&gt;的转换为objc_msgSend的函数调用。这个函数将消息的接受者与该
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>MAC OSX通过Terminal命令行控制蓝牙状态开关</title>
    <link href="http://zvan.xyz/2015/10/28/MAC%20OSX%E9%80%9A%E8%BF%87Terminal%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A7%E5%88%B6%E8%93%9D%E7%89%99%E7%8A%B6%E6%80%81%E5%BC%80%E5%85%B3/"/>
    <id>http://zvan.xyz/2015/10/28/MAC OSX通过Terminal命令行控制蓝牙状态开关/</id>
    <published>2015-10-28T15:16:00.000Z</published>
    <updated>2015-10-28T15:17:36.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;defaults write /Library/Preferences/com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.Bluetooth&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.plist&lt;/span&gt; ControllerPowerState &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
#关闭蓝牙服务

defaults write /Library/Preferences/com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.Bluetooth&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.plist&lt;/span&gt; ControllerPowerState &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;
#打开蓝牙服务

killall blued
#结束所有蓝牙服务进程

launchctl unload /System/Library/LaunchDaemons/com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.blued&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.plist&lt;/span&gt;
#卸载蓝牙Daemon

launchctl load /System/Library/LaunchDaemons/com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.blued&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.plist&lt;/span&gt;
#载入蓝牙Daemon

launchctl start com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.blued&lt;/span&gt;
#重启蓝牙Daemon
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://discussions.apple.com/thread/2619301?tstart=0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://discussions.apple.com/thread/2619301?tstart=0&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;defaults write /Library/Preferences/com&lt;span class=&quot;class&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.Bluetooth&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;
    
    </summary>
    
      <category term="MAC应用" scheme="http://zvan.xyz/categories/MAC%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="MAC" scheme="http://zvan.xyz/tags/MAC/"/>
    
      <category term="蓝牙" scheme="http://zvan.xyz/tags/%E8%93%9D%E7%89%99/"/>
    
  </entry>
  
  <entry>
    <title>解决在iOS8环境下,当用户关闭定位服务总开关时,无法将APP定位子选项加入定位权限列表的问题</title>
    <link href="http://zvan.xyz/2015/10/27/%E8%A7%A3%E5%86%B3%E5%9C%A8iOS8%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BD%93%E7%94%A8%E6%88%B7%E5%85%B3%E9%97%AD%E5%AE%9A%E4%BD%8D%E6%9C%8D%E5%8A%A1%E6%80%BB%E5%BC%80%E5%85%B3%E6%97%B6%E6%97%A0%E6%B3%95%E5%B0%86APP%E5%AE%9A%E4%BD%8D%E5%AD%90%E9%80%89%E9%A1%B9%E5%8A%A0%E5%85%A5%E5%AE%9A%E4%BD%8D%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zvan.xyz/2015/10/27/解决在iOS8环境下当用户关闭定位服务总开关时无法将APP定位子选项加入定位权限列表的问题/</id>
    <published>2015-10-27T15:34:32.000Z</published>
    <updated>2015-10-27T16:08:39.000Z</updated>
    
    <content type="html">&lt;pre&gt;&lt;code&gt;关键点：
&lt;span class=&quot;pp&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;locationManager:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;CLLocationManager&lt;/span&gt; *)&lt;/span&gt;manager didChangeAuthorizationStatus:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;CLAuthorizationStatus&lt;/span&gt;)&lt;/span&gt;status代理方法&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iOS7环境下当APP首次调用startUpdatingLocation方法开启定位服务时，系统会自动将该APP的定位子选项加入设置中的定位权限列表，并弹框提示用户是否为该APP定位服务授权。&lt;/p&gt;
&lt;p&gt;可是在iOS8环境下，使用定位服务的方式较之前版本发生改变，调用startUpdatingLocation方法前需要调用requestWhenInUseAuthorization方法来请求定位权限； 但是在用户关闭定位服务总开关时，单单使用该方法却无法将APP定位的子选项加入定位权限列表，用户在打开定位总开关后是找不到该APP的子选项的，除非在定位服务总开关打开的情况下才能正常加入权限列表；&lt;/p&gt;
&lt;p&gt;解决方法是将开启定位的startUpdatingLocation方法放在didChangeAuthorizationStatus:代理方法中调用：&lt;br&gt;1）首先调用requestWhenInUseAuthorization方法请求定位权限（iOS7及以前无需调用此方法）;&lt;br&gt;2）然后在didChangeAuthorizationStatus:代理方法中调用startUpdatingLocation方法请求一次定位；&lt;br&gt;采用这种方式解决，无论定位服务的总开关是否打开，都能将APP的定位子选项加入定位权限列表。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;关键点：
&lt;span class=&quot;pp&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;locationManager:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;CLLocation
    
    </summary>
    
      <category term="iOS开发" scheme="http://zvan.xyz/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="http://zvan.xyz/tags/iOS/"/>
    
      <category term="定位" scheme="http://zvan.xyz/tags/%E5%AE%9A%E4%BD%8D/"/>
    
      <category term="地图" scheme="http://zvan.xyz/tags/%E5%9C%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>重新起航。</title>
    <link href="http://zvan.xyz/2015/10/25/%E9%87%8D%E6%96%B0%E8%B5%B7%E8%88%AA/"/>
    <id>http://zvan.xyz/2015/10/25/重新起航/</id>
    <published>2015-10-25T05:04:34.000Z</published>
    <updated>2015-10-25T05:15:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/15102501.jpg&quot; alt=&quot;重新起航&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/15102501.jpg&quot; alt=&quot;重新起航&quot;&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="日志" scheme="http://zvan.xyz/categories/%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
</feed>
